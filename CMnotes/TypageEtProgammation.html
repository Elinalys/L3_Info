<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</head>
<body>
<!-- # -->
<title>
Typages et programmation - Option
</title>
<h1 id="simuler-de-lobjet-en-c-modularité">Simuler de l'objet en C (modularité)</h1>
<p>Encapsulation des données, constructeur...</p>
<p>Programmation modulaire en C : <em>diviser le programme en modules qui intérragissent</em>, elle se fait ici à travers 2 fichiers : - Le <code>.h</code> : le header, l'information publique du module (en objet on appelle ça une interface) - Le <code>.c</code> : l'implémentation de l'interface</p>
<p><strong>Avantage :</strong> Le monde extérieur ne connaît que ce qui est dans le <code>.h</code>. On peut donc modifier son implémentation à volonté.</p>
<p><em>Par exemple :</em> Les modules, <code>string</code>, <code>stack</code>...</p>
<h2 id="écrire-un-module-de-vecteur-extensible">Écrire un module de vecteur extensible</h2>
<blockquote>
<p>pseudo code</p>
</blockquote>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* vecteur.h */</span>
<span class="pp">#ifndef v_H</span>
<span class="pp">#define v_H</span>

<span class="kw">typedef</span> <span class="kw">struct</span> vecteur *vecteur;
<span class="dt">void</span> liberer(vecteur v);
vecteur creerVecteur();
<span class="dt">void</span> *get(vecteur v, <span class="dt">int</span> i);
<span class="dt">void</span> set(vecteur, <span class="dt">int</span> i, <span class="dt">void</span> *e);
<span class="dt">int</span> length (vecteur v);
<span class="pp">#endif</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* vecteur .c */</span>

<span class="pp">#include </span><span class="im">&quot;vecteur.h&quot;</span>

<span class="kw">struct</span> vecteur {
    <span class="dt">void</span> **tab;
    <span class="dt">void</span> (*liberer)(<span class="dt">void</span> *);
    <span class="dt">int</span> taille;
};

vecteur creerVecteur(<span class="co">/*?*/</span> <span class="dt">void</span> (*lib)(<span class="dt">void</span> *)) {
    vecteur v = malloc(<span class="kw">sizeof</span>(vecteur));
    v-&gt;tab = malloc(<span class="dv">5</span>);
    v-&gt;taille = <span class="dv">5</span>;
    v-&gt;liberer = lib;
    <span class="cf">return</span> v;
}

<span class="dt">void</span> *get(vecteur v, <span class="dt">int</span> i) {
    <span class="cf">if</span> (i &gt; v-&gt;taille<span class="dv">-1</span>) {
        printf(<span class="st">&quot;erreur&quot;</span>);
    }
    <span class="cf">return</span> v-&gt;tab[i];
}

<span class="co">// rappel on ne gère pas toutes les erreurs dans ce code</span>
<span class="dt">int</span> length(vecteur v) {
    <span class="cf">return</span> v-&gt;taille;
}

<span class="dt">void</span> set(vecteur v, <span class="dt">int</span> i, <span class="dt">void</span> *e) {
    <span class="cf">if</span> (i &lt; v-&gt;taille) {
     v-&gt;tab[i] = e;
    }
    <span class="cf">else</span> {
            v-&gt;tab = realloc(<span class="dv">2</span>*v-&gt;taille);
            v-&gt;tab[i] = e;
    }
}

<span class="dt">void</span> liberer(vecteur v) {
    <span class="dt">void</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; v-&gt;taille; i++) {
        v-&gt;liberer(get(v,i));
    }
    free(v-&gt;tab);
    free(v);
}</code></pre></div>
<h1 id="chapitre-1-introduction-au-typage">Chapitre 1 : Introduction au typage</h1>
<p>On voudrait vérifier certaines propriétés :</p>
<ul>
<li>terminaison : est-ce que le programme tourner indéfiniment ? C'est une question non décidable en général.</li>
<li>correction / vérification : est-ce que le programme vérifie certaines propriétés :
<ul>
<li>accès à des pointeurs NULL.</li>
<li>accès à une case non existante d'un tableau.</li>
</ul></li>
</ul>
<p>Globalement non décidable mais une sous-partie non négligeable (% à nos besoins) est décidable.</p>
<p>Pour ces vérifications, on a plusieurs méthodes :</p>
<ul>
<li>analyse statique (ex : à la compilation)</li>
<li>analyse dynamique à l'exécution (des tests, monitoring à l'exécution avec <em>gdb</em> par exemple ou outil de vérification formelle, <em>coq</em>)</li>
</ul>
<p>Les langages de programmation ne se distinguent pas par leur expressivité. → Ce que l'on peut écrire avec le langage <em>L1</em> on peut le faire avec le langage <em>L2</em></p>
<p>On les différencie par leur capacité à faciliter le travail du programmeur : Le typage (types et systèmes de types) est un des moyens de les différencier. Il n'y a pas beaucoup de solutions : il faut rester dans un cadre décidable. Ensuite statique ? dynamique ? fort ? faible ? etc.</p>
<p>2 références sur le typage :</p>
<ul>
<li><em>Pierce B.C Types and Programming languages MIT Press 2002</em> (plus facile)</li>
<li><em>Cardelli : Types Systems CRC Press 1997</em></li>
</ul>
<h2 id="un-langage-non-typé-basé-sur-les-machines-de-turing">Un langage non typé basé sur les machines de Turing</h2>
<p>Un programme dans une machine de Turing est un ensemble de quadruplet (<em>qi, sj, Ah, qk</em>) <em>qk</em> état après avoir exécuté l'instruction</p>
<ul>
<li><em>qi</em> est la valeur d'un état</li>
<li><em>sj</em> est un symbole parmi un ensemble S (on va dire {0,1}) qui sont lus sur une bande</li>
<li><em>Ah</em> est un symbole {→, ←} (déplacer la tête à droite ou à gauche)</li>
<li>On dispose d'une instruction initiale (<em>q0, s0, A0, q'0</em>)</li>
</ul>
<p>Le programme s'arrête lorsque aucune règle ne peut-être appliquée.</p>
<p>On sait d'après Turing (36) que toutes les fonctions décidables admettent un programme dans ce langage.</p>
<p>Testez combien c'est verbeux avec la multiplication de suites binaires dans un tel langage.</p>
<h2 id="deuxième-langage-non-typé-λ-calcul-pur-church">Deuxième langage non typé : λ-calcul pur (Church)</h2>
<h3 id="syntaxe"><strong>Syntaxe</strong></h3>
<p>on a : - <em>V</em> : un ensemble de variables - <em>Σ</em> : V U {<em>λ, (, ), .</em>}</p>
<p>Un λ-terme c'est : - <em>x</em> appartenant à V. - <em>x</em> appartenant à V, M un λ-terme, alors λx.M est un λ-terme - M1 et M2 sont des λ-termes, alors (M1 M2) est un λ-terme</p>
<p><em>exemple</em> : λx.x, fonction identité. (x x). λx.λx.x, ceci va questionner sur l'ordre d'évaluation</p>
<h3 id="comment-on-peut-coder-les-entiers">Comment on peut coder les entiers</h3>
<p>(Par induction)</p>
<ul>
<li>0 c'est λf.λx.x</li>
<li>1 c'est λf.λx.(f).x</li>
<li>2 c'est λf.λx.(f)(f).x</li>
</ul>
<p>Dans de tels langages non typés, certaines questions se posent rapidement : * Je veux écrire une fonction qui ne manipule qu'un certain nombre d'objets (exemple : λ-terme représentant les entiers). Comment faire ? * Comment être certain que vous renvoyez bien un entier ? * Comment distinguer les fonctions ? * Comment bien représenter les objets ? but : faciliter le calcul</p>
<p>→ Le typages c'est entre autres essayer de répondre à ce type de questions.</p>
<p>Le typage permet de vérifier une cohérence entre des ensembles de valeurs et le comportement souhaité.</p>
<p>Pour des soucis d'efficacité des choix ont été faits sur la représentation des valeurs (ceci facilite par exemple la génération de code)</p>
<h2 id="définition">Définition</h2>
<p>Un type est constitué : - D'un ensemble de valeurs (E) - Un ensemble d'opérations sur les valeurs de E (les opérations définissent les propriétés)</p>
<p><em>exemple</em> : (int, (+,-,/,%,&lt;=,&gt;=))</p>
<p>Un langage est dit <em>typé</em> si à certains de ces éléments on associe un type.</p>
<h3 id="question-de-base">Question de base</h3>
<p>Comment identifier (se réduit) les objets typables ? (environnement + élément typable) : peut-on déduire son type ?</p>
<p>Le système de type d'un langage c'est * un ensemble de types * un ensemble de règles permettant de répondre (ou partiellement ) à la question de base</p>
<p>Dans un type on distingue : - la description mathématique du type (TDA, comportements des fonctions sur les valeurs) : <em>version abstraite</em> - l'implémentation (comment on représente les valeurs, l'implémentation concrète des opérations) <em>version concrète</em></p>
<p>La représentation (ou implémentation) concrète peut être réalisée * au niveau matériel (circuit faisant les opérations pour les entiers) * au niveau logiciel (en manipulant d'autres types et les opérations seront souvent des fonctions)</p>
<h4 id="exemple">Exemple :</h4>
<ul>
<li><p><em>Entiers</em> : (Z, + : Z × Z → Z)<br />
Comment &quot;+&quot; opère sur les 2 valeurs est spécifiée par la représentation mathématique du type. (&quot;×&quot; ici produit cartésien).</p></li>
<li><p><em>Pile</em> : (Pile, Objet, empiler : Pile × Objet → Pile, dépiler : Pile → Pile, sommet : Pile → Objet)</p></li>
</ul>
<p>Lorsque l'on a une description du type, on est en mesure de cacher l'implémentation. Lorsque l'on donne une spécification on la voudrait non ambiguë (pas plusieurs possibilités)</p>
<p>La définition mathématique sera basée sur <em>l'algèbre</em> avec des opérations ensemblistes. En général on a au moins deux types d'ensembles dans la définition du type : * l'ensemble représentant les données * l'ensemble représentant l'objet à définir</p>
<h4 id="exemple-pile">Exemple : Pile</h4>
<ul>
<li>Ensemble des objets que l'on stocke.</li>
<li>Ensemble des piles.</li>
</ul>
<p>Chaque opération il faudra dire si elle s'applique à l'ensemble des données ? à l'ensemble de l'objet à définir ? aux 2 ?</p>
<h4 id="exemple-listes">Exemple : Listes</h4>
<p>(et variantes pile, file, ...)</p>
<ul>
<li>Arbres</li>
</ul>
<p>Vu que pour 1 type on a peut-être besoin d'autres types, il y a une hiérarchie dans les types : * Les types de base (Ex en C : <code>int, float, char, double</code>) * les types construits (ou composites) à partir de types existants (Ex en C : les tableaux, <code>struct</code>, <code>enum</code>). Ils sont obtenus à partir d'opérateurs (donnés avec le langage). * Les types proposés par le langage et différents des... (Ex: en C++ <code>bool</code>)</p>
<p>On fait la différence entre les types proposés et les types de base qui sont des types atomiques, des autres types proposées par le langage qui peuvent être obtenus par construction à base d'autres types.</p>
<h4 id="exemple-de-constructeurs-pour-des-types-composés">Exemple de constructeurs pour des types composés :</h4>
<ul>
<li>enregistrements (<code>struct, union</code> en C)</li>
<li>modules (lanages ML)</li>
<li>classes (Java, C++,...)</li>
<li>fichiers (comme encapsulateurs)</li>
<li>fonctions (langages fonctionnels)</li>
</ul>
<h2 id="propriétés-des-systèmes-de-types">Propriétés des systèmes de types</h2>
<p>3 façons de caractériser les systèmes de types :</p>
<ul>
<li>statique ou dynamique</li>
<li>les types sont explicites ou implicites</li>
<li>le système est faible ou fort (avec des degrés)</li>
</ul>
<p>Nos fonctions pour avoir du contrôle sur les entrées ou les valeurs manipulées, on donne des types aux entrées et aux valeurs manipulées. Le système de types pour contrôler la validité des types a deux stratégies :</p>
<ul>
<li><strong>statique</strong> : le contrôle est fait pendant la compilation (langages dits <em>statiques</em>)</li>
<li><strong>dynamique</strong> : les contrôles sont faits pendant l'exécution, ceci suppose que les valeurs sont annotés avec le type pour vérifier la cohérence avant utilisation</li>
</ul>
<p>On parlera de langage dynamique lorsque ce dernier a une stratégie dynamique. Certains langages peuvent mélanger les 2 stratégies.</p>
<h3 id="exemple-de-langage-dynamique-scheme">Exemple de langage dynamique : Scheme</h3>
<blockquote>
<p>(version guile)</p>
</blockquote>
<p>Fonctionnel et dérivé du Lisp. C'est un langage interprété.</p>
<pre><code>scheme@(guile-user)&gt; (define (f x) (+ x &quot;a&quot;))
scheme@(guile-user)&gt; (f 3)
&lt;unnamed port&gt;:1:14: In procedure f:
&lt;unnamed port&gt;:1:14: In procedure +: Wrong type: &quot;a&quot;</code></pre>
<pre><code>scheme@(guile-user) [2]&gt; (define (f y) (* g y))
;;; &lt;stdin&gt;:2:14: warning: possibly unbound variable `g&#39;
scheme@(guile-user) [2]&gt; (f 3)
&lt;unnamed port&gt;:2:0: In procedure f:
&lt;unnamed port&gt;:2:0: In procedure module-lookup: Unbound variable: g</code></pre>
</body>
</html>
