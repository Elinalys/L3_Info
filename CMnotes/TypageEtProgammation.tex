\documentclass[]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Ligatures=TeX,Scale=MatchLowercase}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{%
\usepackage[]{microtype}
\UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\PassOptionsToPackage{hyphens}{url} % url is loaded by hyperref
\usepackage[unicode=true]{hyperref}
\hypersetup{
            pdfborder={0 0 0},
            breaklinks=true}
\urlstyle{same}  % don't use monospace font for urls
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\newenvironment{Shaded}{}{}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{#1}}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{#1}}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{#1}}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{#1}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{#1}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\IfFileExists{parskip.sty}{%
\usepackage{parskip}
}{% else
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{0}
% Redefines (sub)paragraphs to behave more like sections
\ifx\paragraph\undefined\else
\let\oldparagraph\paragraph
\renewcommand{\paragraph}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
\let\oldsubparagraph\subparagraph
\renewcommand{\subparagraph}[1]{\oldsubparagraph{#1}\mbox{}}
\fi

% set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother


\date{}

\begin{document}

\title{Typages et programmation - Option}

\maketitle

\section{Simuler de l'objet en C
(modularité)}\label{simuler-de-lobjet-en-c-modularituxe9}

Encapsulation des données, constructeur\ldots{}

Programmation modulaire en C : \emph{diviser le programme en modules qui
intérragissent}, elle se fait ici à travers 2 fichiers : - Le
\texttt{.h} : le header, l'information publique du module (en objet on
appelle ça une interface) - Le \texttt{.c} : l'implémentation de
l'interface

\textbf{Avantage :} Le monde extérieur ne connaît que ce qui est dans le
\texttt{.h}. On peut donc modifier son implémentation à volonté.

\emph{Par exemple :} Les modules, \texttt{string},
\texttt{stack}\ldots{}

\subsection{Écrire un module de vecteur
extensible}\label{uxe9crire-un-module-de-vecteur-extensible}

\begin{quote}
pseudo code
\end{quote}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{/* vecteur.h */}
\PreprocessorTok{#ifndef v_H}
\PreprocessorTok{#define v_H}

\KeywordTok{typedef} \KeywordTok{struct}\NormalTok{ vecteur *vecteur;}
\DataTypeTok{void}\NormalTok{ liberer(vecteur v);}
\NormalTok{vecteur creerVecteur();}
\DataTypeTok{void}\NormalTok{ *get(vecteur v, }\DataTypeTok{int}\NormalTok{ i);}
\DataTypeTok{void}\NormalTok{ set(vecteur, }\DataTypeTok{int}\NormalTok{ i, }\DataTypeTok{void}\NormalTok{ *e);}
\DataTypeTok{int}\NormalTok{ length (vecteur v);}
\PreprocessorTok{#endif}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{/* vecteur .c */}

\PreprocessorTok{#include }\ImportTok{"vecteur.h"}

\KeywordTok{struct}\NormalTok{ vecteur \{}
    \DataTypeTok{void}\NormalTok{ **tab;}
    \DataTypeTok{void}\NormalTok{ (*liberer)(}\DataTypeTok{void}\NormalTok{ *);}
    \DataTypeTok{int}\NormalTok{ taille;}
\NormalTok{\};}

\NormalTok{vecteur creerVecteur(}\CommentTok{/*?*/} \DataTypeTok{void}\NormalTok{ (*lib)(}\DataTypeTok{void}\NormalTok{ *)) \{}
\NormalTok{    vecteur v = malloc(}\KeywordTok{sizeof}\NormalTok{(vecteur));}
\NormalTok{    v->tab = malloc(}\DecValTok{5}\NormalTok{);}
\NormalTok{    v->taille = }\DecValTok{5}\NormalTok{;}
\NormalTok{    v->liberer = lib;}
    \ControlFlowTok{return}\NormalTok{ v;}
\NormalTok{\}}

\DataTypeTok{void}\NormalTok{ *get(vecteur v, }\DataTypeTok{int}\NormalTok{ i) \{}
    \ControlFlowTok{if}\NormalTok{ (i > v->taille}\DecValTok{-1}\NormalTok{) \{}
\NormalTok{        printf(}\StringTok{"erreur"}\NormalTok{);}
\NormalTok{    \}}
    \ControlFlowTok{return}\NormalTok{ v->tab[i];}
\NormalTok{\}}

\CommentTok{// rappel on ne gère pas toutes les erreurs dans ce code}
\DataTypeTok{int}\NormalTok{ length(vecteur v) \{}
    \ControlFlowTok{return}\NormalTok{ v->taille;}
\NormalTok{\}}

\DataTypeTok{void}\NormalTok{ set(vecteur v, }\DataTypeTok{int}\NormalTok{ i, }\DataTypeTok{void}\NormalTok{ *e) \{}
    \ControlFlowTok{if}\NormalTok{ (i < v->taille) \{}
\NormalTok{     v->tab[i] = e;}
\NormalTok{    \}}
    \ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{            v->tab = realloc(}\DecValTok{2}\NormalTok{*v->taille);}
\NormalTok{            v->tab[i] = e;}
\NormalTok{    \}}
\NormalTok{\}}

\DataTypeTok{void}\NormalTok{ liberer(vecteur v) \{}
    \DataTypeTok{void}\NormalTok{ (}\DataTypeTok{int}\NormalTok{ i = }\DecValTok{0}\NormalTok{; i < v->taille; i++) \{}
\NormalTok{        v->liberer(get(v,i));}
\NormalTok{    \}}
\NormalTok{    free(v->tab);}
\NormalTok{    free(v);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\section{Chapitre 1 : Introduction au
typage}\label{chapitre-1-introduction-au-typage}

On voudrait vérifier certaines propriétés :

\begin{itemize}
\tightlist
\item
  terminaison : est-ce que le programme tourner indéfiniment ? C'est une
  question non décidable en général.
\item
  correction / vérification : est-ce que le programme vérifie certaines
  propriétés :

  \begin{itemize}
  \tightlist
  \item
    accès à des pointeurs NULL.
  \item
    accès à une case non existante d'un tableau.
  \end{itemize}
\end{itemize}

Globalement non décidable mais une sous-partie non négligeable (\% à nos
besoins) est décidable.

Pour ces vérifications, on a plusieurs méthodes :

\begin{itemize}
\tightlist
\item
  analyse statique (ex : à la compilation)
\item
  analyse dynamique à l'exécution (des tests, monitoring à l'exécution
  avec \emph{gdb} par exemple ou outil de vérification formelle,
  \emph{coq})
\end{itemize}

Les langages de programmation ne se distinguent pas par leur
expressivité. → Ce que l'on peut écrire avec le langage \emph{L1} on
peut le faire avec le langage \emph{L2}

On les différencie par leur capacité à faciliter le travail du
programmeur : Le typage (types et systèmes de types) est un des moyens
de les différencier. Il n'y a pas beaucoup de solutions : il faut rester
dans un cadre décidable. Ensuite statique ? dynamique ? fort ? faible ?
etc.

2 références sur le typage :

\begin{itemize}
\tightlist
\item
  \emph{Pierce B.C Types and Programming languages MIT Press 2002} (plus
  facile)
\item
  \emph{Cardelli : Types Systems CRC Press 1997}
\end{itemize}

\subsection{Un langage non typé basé sur les machines de
Turing}\label{un-langage-non-typuxe9-basuxe9-sur-les-machines-de-turing}

Un programme dans une machine de Turing est un ensemble de quadruplet
(\emph{qi, sj, Ah, qk}) \emph{qk} état après avoir exécuté l'instruction

\begin{itemize}
\tightlist
\item
  \emph{qi} est la valeur d'un état
\item
  \emph{sj} est un symbole parmi un ensemble S (on va dire \{0,1\}) qui
  sont lus sur une bande
\item
  \emph{Ah} est un symbole \{→, ←\} (déplacer la tête à droite ou à
  gauche)
\item
  On dispose d'une instruction initiale (\emph{q0, s0, A0, q'0})
\end{itemize}

Le programme s'arrête lorsque aucune règle ne peut-être appliquée.

On sait d'après Turing (36) que toutes les fonctions décidables
admettent un programme dans ce langage.

Testez combien c'est verbeux avec la multiplication de suites binaires
dans un tel langage.

\subsection{Deuxième langage non typé : λ-calcul pur
(Church)}\label{deuxiuxe8me-langage-non-typuxe9-ux3bb-calcul-pur-church}

\subsubsection{\texorpdfstring{\textbf{Syntaxe}}{Syntaxe}}\label{syntaxe}

on a : - \emph{V} : un ensemble de variables - \emph{Σ} : V U \{\emph{λ,
(, ), .}\}

Un λ-terme c'est : - \emph{x} appartenant à V. - \emph{x} appartenant à
V, M un λ-terme, alors λx.M est un λ-terme - M1 et M2 sont des λ-termes,
alors (M1 M2) est un λ-terme

\emph{exemple} : λx.x, fonction identité. (x x). λx.λx.x, ceci va
questionner sur l'ordre d'évaluation

\subsubsection{Comment on peut coder les
entiers}\label{comment-on-peut-coder-les-entiers}

(Par induction)

\begin{itemize}
\tightlist
\item
  0 c'est λf.λx.x
\item
  1 c'est λf.λx.(f).x
\item
  2 c'est λf.λx.(f)(f).x
\end{itemize}

Dans de tels langages non typés, certaines questions se posent
rapidement : * Je veux écrire une fonction qui ne manipule qu'un certain
nombre d'objets (exemple : λ-terme représentant les entiers). Comment
faire ? * Comment être certain que vous renvoyez bien un entier ? *
Comment distinguer les fonctions ? * Comment bien représenter les objets
? but : faciliter le calcul

→ Le typages c'est entre autres essayer de répondre à ce type de
questions.

Le typage permet de vérifier une cohérence entre des ensembles de
valeurs et le comportement souhaité.

Pour des soucis d'efficacité des choix ont été faits sur la
représentation des valeurs (ceci facilite par exemple la génération de
code)

\subsection{Définition}\label{duxe9finition}

Un type est constitué : - D'un ensemble de valeurs (E) - Un ensemble
d'opérations sur les valeurs de E (les opérations définissent les
propriétés)

\emph{exemple} : (int, (+,-,/,\%,\textless{}=,\textgreater{}=))

Un langage est dit \emph{typé} si à certains de ces éléments on associe
un type.

\subsubsection{Question de base}\label{question-de-base}

Comment identifier (se réduit) les objets typables ? (environnement +
élément typable) : peut-on déduire son type ?

Le système de type d'un langage c'est * un ensemble de types * un
ensemble de règles permettant de répondre (ou partiellement ) à la
question de base

Dans un type on distingue : - la description mathématique du type (TDA,
comportements des fonctions sur les valeurs) : \emph{version abstraite}
- l'implémentation (comment on représente les valeurs, l'implémentation
concrète des opérations) \emph{version concrète}

La représentation (ou implémentation) concrète peut être réalisée * au
niveau matériel (circuit faisant les opérations pour les entiers) * au
niveau logiciel (en manipulant d'autres types et les opérations seront
souvent des fonctions)

\paragraph{Exemple :}\label{exemple}

\begin{itemize}
\item
  \emph{Entiers} : (Z, + : Z × Z → Z)\\
  Comment ``+'' opère sur les 2 valeurs est spécifiée par la
  représentation mathématique du type. (``×'' ici produit cartésien).
\item
  \emph{Pile} : (Pile, Objet, empiler : Pile × Objet → Pile, dépiler :
  Pile → Pile, sommet : Pile → Objet)
\end{itemize}

Lorsque l'on a une description du type, on est en mesure de cacher
l'implémentation. Lorsque l'on donne une spécification on la voudrait
non ambiguë (pas plusieurs possibilités)

La définition mathématique sera basée sur \emph{l'algèbre} avec des
opérations ensemblistes. En général on a au moins deux types d'ensembles
dans la définition du type : * l'ensemble représentant les données *
l'ensemble représentant l'objet à définir

\paragraph{Exemple : Pile}\label{exemple-pile}

\begin{itemize}
\tightlist
\item
  Ensemble des objets que l'on stocke.
\item
  Ensemble des piles.
\end{itemize}

Chaque opération il faudra dire si elle s'applique à l'ensemble des
données ? à l'ensemble de l'objet à définir ? aux 2 ?

\paragraph{Exemple : Listes}\label{exemple-listes}

(et variantes pile, file, \ldots{})

\begin{itemize}
\tightlist
\item
  Arbres
\end{itemize}

Vu que pour 1 type on a peut-être besoin d'autres types, il y a une
hiérarchie dans les types : * Les types de base (Ex en C :
\texttt{int,\ float,\ char,\ double}) * les types construits (ou
composites) à partir de types existants (Ex en C : les tableaux,
\texttt{struct}, \texttt{enum}). Ils sont obtenus à partir d'opérateurs
(donnés avec le langage). * Les types proposés par le langage et
différents des\ldots{} (Ex: en C++ \texttt{bool})

On fait la différence entre les types proposés et les types de base qui
sont des types atomiques, des autres types proposées par le langage qui
peuvent être obtenus par construction à base d'autres types.

\paragraph{Exemple de constructeurs pour des types composés
:}\label{exemple-de-constructeurs-pour-des-types-composuxe9s}

\begin{itemize}
\tightlist
\item
  enregistrements (\texttt{struct,\ union} en C)
\item
  modules (lanages ML)
\item
  classes (Java, C++,\ldots{})
\item
  fichiers (comme encapsulateurs)
\item
  fonctions (langages fonctionnels)
\end{itemize}

\subsection{Propriétés des systèmes de
types}\label{propriuxe9tuxe9s-des-systuxe8mes-de-types}

3 façons de caractériser les systèmes de types :

\begin{itemize}
\tightlist
\item
  statique ou dynamique
\item
  les types sont explicites ou implicites
\item
  le système est faible ou fort (avec des degrés)
\end{itemize}

Nos fonctions pour avoir du contrôle sur les entrées ou les valeurs
manipulées, on donne des types aux entrées et aux valeurs manipulées. Le
système de types pour contrôler la validité des types a deux stratégies
:

\begin{itemize}
\tightlist
\item
  \textbf{statique} : le contrôle est fait pendant la compilation
  (langages dits \emph{statiques})
\item
  \textbf{dynamique} : les contrôles sont faits pendant l'exécution,
  ceci suppose que les valeurs sont annotés avec le type pour vérifier
  la cohérence avant utilisation
\end{itemize}

On parlera de langage dynamique lorsque ce dernier a une stratégie
dynamique. Certains langages peuvent mélanger les 2 stratégies.

\subsubsection{Exemple de langage dynamique :
Scheme}\label{exemple-de-langage-dynamique-scheme}

\begin{quote}
(version guile)
\end{quote}

Fonctionnel et dérivé du Lisp. C'est un langage interprété.

\begin{verbatim}
scheme@(guile-user)> (define (f x) (+ x "a"))
scheme@(guile-user)> (f 3)
<unnamed port>:1:14: In procedure f:
<unnamed port>:1:14: In procedure +: Wrong type: "a"
\end{verbatim}

\begin{verbatim}
scheme@(guile-user) [2]> (define (f y) (* g y))
;;; <stdin>:2:14: warning: possibly unbound variable `g'
scheme@(guile-user) [2]> (f 3)
<unnamed port>:2:0: In procedure f:
<unnamed port>:2:0: In procedure module-lookup: Unbound variable: g
\end{verbatim}

\subsubsection{Avantages de la stratégie
statique}\label{avantages-de-la-stratuxe9gie-statique}

\begin{itemize}
\tightlist
\item
  détection : des erreurs potentielles liées aux types avant l'exécution
  (évaluation).
\item
  documentation des erreurs liée aux types.
\item
  parfois le compilateur permet d'optimiser le code.
\end{itemize}

\subsubsection{Explicite vs Implicite}\label{explicite-vs-implicite}

Un système de types est dit explicite si les types doivent être
déclarés. Sinon il est implicite

\begin{itemize}
\tightlist
\item
  Implicite : C, Java, \ldots{}
\item
  Explicite : Python, OCaml, Javascript, Scheme
\end{itemize}

Un langage est implicite et statique doit avoir un moyen de vérifier les
types à la compilation. Ce mécanisme c'est l'inférence de types.

\textbf{Souvent} explicite et statique vont ensemble (Ada, C, Java),
implicite et dynamique aussi (SmallTalk python), \textbf{Mais pas
toujours} famille ML implicite et statique

\subsubsection{Système fort vs faible}\label{systuxe8me-fort-vs-faible}

Un système statique est dit \textbf{fort} si aucune erreur de type ne se
produit pendant l'exécution. Un langage qui contient un système de type
Fort est dit fortement typé. Tout langage non fortement possède un
système de type dit \textbf{faible}.

\paragraph{Vue ensembliste}\label{vue-ensembliste}

Pok = l'ensemble des programmes syntaxiquement corrects

Psafe = ceux à l'exécution sans erreurs de type

Fort \textless{}=\textgreater{} Pok = Psafe Faible
\textless{}=\textgreater{} Pok ~Psafe != ø

Si votre langage a la même puissance que la machine de Turing
=\textgreater{} il ne peut pas être fort

\emph{Ex :} On ne peut pas détecter dans x/y que y != 0.

Les faibles seront classifiés par rapport aux types \emph{d'erreur} :

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Les erreurs non détectées à la compilation comme à l'exécution. (C,
  C++)
\item
  Avortement brutal sans information.
\item
  Déclenchement d'exceptions pour permettre aux programmeur de récupérer
  l'erreur. (Ocaml, Java)
\item
  Le compilateur refuse l'expression sans information.
\item
  Refus de l'erreur et indication.
\end{enumerate}

Un système de type est d'ordre \emph{j} si les programmes engendrent des
erreurs au plus \emph{i}.

\textbf{L. Cardelli} : Considère un type fort ceux d'ordre au moins 2.

\subsubsection{EXO}\label{exo}

\paragraph{C}\label{c}

Un ou plusieurs exemples d'ordre 1.

Accès à une case non existante d'un tableau

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{#include }\ImportTok{<stdio.h>}

\DataTypeTok{int}\NormalTok{ main() \{}
    \DataTypeTok{int}\NormalTok{ tab[}\DecValTok{3}\NormalTok{] = \{}\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{\};}
\NormalTok{    printf(}\StringTok{"%d}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, tab[}\DecValTok{4}\NormalTok{]);}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Les \emph{casts} en C sont physiques et non logiques.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{#include }\ImportTok{<stdio.h>}
\PreprocessorTok{#include }\ImportTok{<stdlib.h>}

\DataTypeTok{int}\NormalTok{ main() \{}
    \DataTypeTok{int}\NormalTok{ *p = malloc(}\KeywordTok{sizeof}\NormalTok{(}\DataTypeTok{int}\NormalTok{));}
\NormalTok{    *p = }\DecValTok{3}\NormalTok{;}
    \DataTypeTok{void}\NormalTok{ *r;}
    \DataTypeTok{float}\NormalTok{ *f;}
\NormalTok{    r = (}\DataTypeTok{void}\NormalTok{ *)p; }\CommentTok{// transition non nécessaire}
\NormalTok{    f = (}\DataTypeTok{float}\NormalTok{ *)r;}
\NormalTok{    printf(}\StringTok{"%d, %g}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, *p, *f);}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\paragraph{Java}\label{java}

Un ou plusieurs exemples d'ordre 3

Hiérarchie des types. \texttt{Object} est le type \emph{racine} en java.
Le cast n'est pas physique mais logique en java.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ Test \{}
    \KeywordTok{public} \DataTypeTok{static} \DataTypeTok{void} \FunctionTok{main}\NormalTok{(}\BuiltInTok{String}\NormalTok{[] args) \{}
        \BuiltInTok{Integer}\NormalTok{ p = }\KeywordTok{new} \BuiltInTok{Integer}\NormalTok{(}\DecValTok{5}\NormalTok{);}
        \BuiltInTok{Object}\NormalTok{ o = (}\BuiltInTok{Object}\NormalTok{)p;}
        \BuiltInTok{Double}\NormalTok{ d = (}\BuiltInTok{Double}\NormalTok{)o;}
\NormalTok{    \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

(\ldots{}) ?

\subsection{Polymorphisme}\label{polymorphisme}

Lorsqu'un objet peut admettre plusieurs types on dit qu'il est
polymorphe.

Le mécanisme dérrière cette propriété est appelé \emph{polymorphisme}.

\emph{Exemple :} Un fonction polymorphe est une fonction dont les
\emph{paramètres} et le \emph{résultat} peuvent être des instances de
plusieurs types différents.

\emph{Remarque :} Un système de types dynamique induit un certain
polymorphisme naturellement.

\subsubsection{On va distinguer plusieurs sortes de
polymorphismes}\label{on-va-distinguer-plusieurs-sortes-de-polymorphismes}

\paragraph{Polymorphisme ad-hoc}\label{polymorphisme-ad-hoc}

Un objet ne peut accepter qu'un ensemble fini de types distincts.

Pas une seule façon d'implémenter ce polymorphisme. Le choix du type
d'un objet peut être soit automatisé (intégré dans le système de types)
soit laissé à la charge du programmeur.

\begin{verbatim}
struct point
{
    float x,
    float y
};

union z {
    int i,
    char c,
    struct point p,
};

/* ... */
\end{verbatim}

\paragraph{Polymorphisme de surcharge}\label{polymorphisme-de-surcharge}

Un même \emph{identificateur} peut représenter un nombre fini d'éléments
distincts du programme c'est une facilité syntaxique. Le choix du bon
objet est fait par le système de types \emph{à la compilation}
(résolution statique).

\emph{Question :}

\begin{verbatim}
int f() {
    /* code */
}

char f() {
    /* code */
}
\end{verbatim}

Impossible en C. Car le compilateur ne saura pas quelle fonction choisir
à la compilation.

/!~En général l'implicite et la surcharge ne vont pas ensemble.

\emph{Exemple en Ocaml :}

\texttt{+} pour les \texttt{int} \texttt{+.} pour les \texttt{float}

\paragraph{Polymorphisme de
coercition}\label{polymorphisme-de-coercition}

Le type \emph{t1} est \textbf{transformable} au type \emph{t2}. Si toute
instance de \emph{t1} peut être transformée en une instance de
\emph{t2}.

Une transformation est faite par le système de types implicitement. Le
polymorphisme de coercition = ensemble fixé (et fini) de transformations
entre types (dans le but de se conformer à un contexte).

La résolution par le système de types statiquement.

\emph{Exemple :} en C : \texttt{4+5.} 4 est transformé en un flottant.

\paragraph{Polymorphisme d'union/somme}\label{polymorphisme-dunionsomme}

La possibilité de construire des types représentants plusieurs types
différents la résolution peut être statique/dynamique une partie est
parfois laissée au programmeur.

\subparagraph{En Ocaml}\label{en-ocaml}

Les types somme et le mécanisme de filtrage. Ce mécanisme permet au
programmeur d'identifier le type réel d'un objet (d'une instance de type
somme par exemple).

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type}\NormalTok{ complex = C }\KeywordTok{of} \DataTypeTok{float}\NormalTok{*}\DataTypeTok{float}\NormalTok{ | R }\KeywordTok{of} \DataTypeTok{float}\NormalTok{ | I }\KeywordTok{of} \DataTypeTok{float}\NormalTok{ ;;}
\end{Highlighting}
\end{Shaded}

On a défini un type \texttt{complex} qui est :

\begin{itemize}
\tightlist
\item
  soit composé de deux flottants, ceux la sont construits avec le
  constructeur \texttt{C}
\item
  soit composé d'un seul flottant construit avec le constructeur
  \texttt{R} (sémantique une partie réelle)
\item
  soit composée d'un seul réel avec le constructeur \texttt{I} (ici
  juste une partie imaginaire)
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let}\NormalTok{ print c = }\KeywordTok{match}\NormalTok{ c }\KeywordTok{with}\NormalTok{ C (x, y) -> }\StringTok{"vrai complex"}
\NormalTok{    | R(x) -> }\StringTok{"complex réel"}
\NormalTok{    | I(x) -> }\StringTok{"complex imaginaire"}\NormalTok{ ;;}

\NormalTok{print complex->}\DataTypeTok{string}\NormalTok{ = <}\KeywordTok{fun}\NormalTok{>}
\end{Highlighting}
\end{Shaded}

\subparagraph{En C}\label{en-c}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ 2reels \{}
    \DataTypeTok{float}\NormalTok{ x;}
    \DataTypeTok{float}\NormalTok{ y;}
\NormalTok{\};}

\KeywordTok{union}\NormalTok{ complex \{}
    \DataTypeTok{float}\NormalTok{ f;}
\NormalTok{    2reels c;}
\NormalTok{\};}

\KeywordTok{struct}\NormalTok{ nombre \{}
\NormalTok{    complex c;}
    \KeywordTok{enum}\NormalTok{ type \{C, R, I\} T;}
\NormalTok{\};}

\DataTypeTok{char}\NormalTok{ *print (nombre n) \{}
    \ControlFlowTok{if}\NormalTok{ (n.T ==C) \{}
        \ControlFlowTok{return} \StringTok{"on attent un vrai complex de type 2reels"}\NormalTok{;}
\NormalTok{    \}}
    \ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (n.T == R) \{}
        \ControlFlowTok{return} \StringTok{"on attend un complex reel"}\NormalTok{;}
\NormalTok{    \}}
    \ControlFlowTok{else}\NormalTok{ \{}
        \ControlFlowTok{return} \StringTok{"on attend un complex imaginaire"}\NormalTok{;}
\NormalTok{    \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\paragraph{Polymorphisme
paramétrique}\label{polymorphisme-paramuxe9trique}

Polymorphisme paramétrique c'est le fait d'utiliser des variables qui
représentent des types. Et ces variables sont instanciées statiquement.

On l'appelle dans certains langages : \textbf{généricité}. À priori
c'est un polymorphisme \emph{universel}. Un polymorphisme universel
signifie que tout élément typable peut être instancié avec un nombre non
borné de types.

\emph{Exemple :} En \texttt{Ocaml}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let}\NormalTok{ id x = x;;}
    \KeywordTok{val}\NormalTok{ id : 'a -> 'a = <}\KeywordTok{fun}\NormalTok{> }\CommentTok{(* Variable représentant n'importe quel type *)}
\end{Highlighting}
\end{Shaded}

En \texttt{C++}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{template}\NormalTok{ <}\KeywordTok{typename}\NormalTok{ T> }\CommentTok{// on déclare le besoin de définir une fonction générique}
\NormalTok{T id(T x) \{}
    \ControlFlowTok{return}\NormalTok{ x;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Un polymorphisme paramétrique implicite : le système de types s'occupe
de la gestion automatique des variables de type. (Exemple : Ocaml)

Généralisation de la notion de système de types implicite. Sinon c'est
explicite (i.e.~on déclare les noms des types) (Exemples : C++, Java,
\dots)

Le système de types va ajouter dans le code du programme une fonction
appelée par exemple \texttt{id\_chart}, qui remplace toute occurrence de
\texttt{id(s)} où \texttt{s} est un \texttt{char{[}{]}}, par
\texttt{id\_chart}.

Le polymorphisme paramétrique contraint on peut typer les variables de
types (?).

→ Cela signifie que l'on peut donner des propriétés que les valeurs de
certaines variables de types doivent satisfaire.

\emph{Exemple :} Java, ML (foncteurs).

\textbf{NB :} Le polymorphisme paramétrique en C++ n'est pas contraint.

Exemple de polymorphisme contraint en Java :

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ C <T }\KeywordTok{implements} \BuiltInTok{Runnable}\NormalTok{> \{}
    \CommentTok{/* ~ */}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Les valeurs possibles pour \texttt{T} sont exactement les classes qui
implémentent \texttt{Runnable}.

\subparagraph{Supposons ces 2 fonctions en
C}\label{supposons-ces-2-fonctions-en-c}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ f() \{}
    \CommentTok{/* code */}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ f() \{}
    \CommentTok{/* code */}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Ces deux fonctions dans le même fichier produit une erreur de
redéfinition → À priori le type de retour n'est pas pris en compte dans
la définition des fonctions. Car idéalement \texttt{int\ f()\ \{\}}
devrait représenter une fonction de type \texttt{void}→\texttt{int}.
\texttt{void\ f()\ \{\}} une fonction de type
\texttt{void}→\texttt{void}.

En C on peut appeler une fonction sans utiliser la valeur de retour.
Cette ambiguïté n'est pas gérée par le compilateur.

En \texttt{Ocaml}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let}\NormalTok{ s a b = a+b;;}
    \KeywordTok{val}\NormalTok{ s : }\DataTypeTok{int}\NormalTok{ -> }\DataTypeTok{int}\NormalTok{ -> }\DataTypeTok{int}\NormalTok{ = <}\KeywordTok{fun}\NormalTok{>}
\KeywordTok{let}\NormalTok{ s a b = a+.b;;}
    \KeywordTok{val}\NormalTok{ s : }\DataTypeTok{float}\NormalTok{ -> }\DataTypeTok{float}\NormalTok{ -> }\DataTypeTok{float}\NormalTok{ = <}\KeywordTok{fun}\NormalTok{>}
\NormalTok{s }\DecValTok{5} \DecValTok{10}\NormalTok{;;}
\NormalTok{Error: This expression has }\KeywordTok{type} \DataTypeTok{int}\NormalTok{ but an expression was expected }\KeywordTok{of} \KeywordTok{type}
         \DataTypeTok{float}
\CommentTok{(* La première définition n'existe plus dans le système s*)}
\end{Highlighting}
\end{Shaded}

Il n'a pas surchargé mais \emph{redéfinit} la fonction \texttt{s}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let}\NormalTok{ f x y = (s x y);; }\CommentTok{(* on appelle la fonction s sur les entrées x et y *)}
\end{Highlighting}
\end{Shaded}

Ici le système de types si on permettait la redéfinition de s, il serait
incapable de choisir parmi les deux car rien ne permet dans
\texttt{(s\ x\ y)} d'inférer les types de \texttt{x} et \texttt{y}.

\subsection{Syntaxe C++ (Différence avec C si
besoin)}\label{syntaxe-c-diffuxe9rence-avec-c-si-besoin}

L'objectif est d'introduire à la fin les fonctions/classes virtuelles.

Le système de types est principalement statique. On peut avoir une
version dynamique, mais à la demande.

\begin{itemize}
\item
  Affichage / Lecture : deux fonctions génériques : \texttt{cout} et
  \texttt{cin}, équivalent de \texttt{printf} et \texttt{scanf} sans
  formatage.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{#include }\ImportTok{<iostream>}\PreprocessorTok{ }\CommentTok{// on définit les fonctions entrée / sortie}
\KeywordTok{using} \KeywordTok{namespace}\NormalTok{ std; }\CommentTok{// package standard appelé namespace en C++, module}
\CommentTok{// cout et cin s'appellent en réalité std::cout et std::cin}
\CommentTok{// facilité syntaxique}
\DataTypeTok{int}\NormalTok{ main() \{}
    \DataTypeTok{int}\NormalTok{ x;}
\NormalTok{    cin >> x; }\CommentTok{// saisie entier}
\NormalTok{    cout << }\StringTok{"entier saisi : "}\NormalTok{ << x << endl;}
    \DataTypeTok{char}\NormalTok{ s[}\DecValTok{100}\NormalTok{];}
\NormalTok{    cin >> s;}
\NormalTok{    cout << }\StringTok{"chaine saisie : "}\NormalTok{ << s << endl;}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\item
  Pour les fichiers

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{#include }\ImportTok{<ofstream>}\PreprocessorTok{ }\CommentTok{// écrire dans un fichier}
\PreprocessorTok{#include }\ImportTok{<ifstream>}\PreprocessorTok{ }\CommentTok{// lire ""}
\DataTypeTok{int}\NormalTok{ main() \{}
\NormalTok{    ifstream f(}\StringTok{"fic1"}\NormalTok{); }\CommentTok{// ouverture en lecture ...}
    \DataTypeTok{char}\NormalTok{ c;}
\NormalTok{    f.get(c); }\CommentTok{// lire un caractère stocké dans c}
\NormalTok{    ofstream g(}\StringTok{"fic2"}\NormalTok{); }\CommentTok{// ouverture en écriture}
\NormalTok{    g.put(c); }\CommentTok{// on écrit le caractère c}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\item
  Un type booléen \texttt{bool}.
\item
  Les mêmes autres types de bases qu'en C. Par exemple pour
  \texttt{int}, versions \texttt{short}, \texttt{long}, \texttt{signed},
  \texttt{unsigned}.
\item
  Les constantes \texttt{const}, sauf qu'en C++ on doit les initialiser.
  La raison : les constantes sont par défaut internes en C++ et externes
  en C.
\item
  En C++ toute variable a une valeur par défaut.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ x; }\CommentTok{// par défaut c'est 0}
\end{Highlighting}
\end{Shaded}
\item
  Les \emph{cast} sont comme en C (physique).
\item
  Les \texttt{enum}, \texttt{union} sont comme en C. En revanche dans
  une \texttt{union} on peut encapsuler des fonctions contrairement au
  C. Pour rappel :

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ x; }\CommentTok{// déclaration}
\DataTypeTok{int}\NormalTok{ x = }\DecValTok{0}\NormalTok{; }\CommentTok{// déclaration + définition}
\end{Highlighting}
\end{Shaded}
\end{itemize}

\end{document}
