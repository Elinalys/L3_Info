\documentclass[11pt, a4paper]{article}

\usepackage[utf8x]{inputenc} % encodage, à modifier selon vos habitudes
% \usepackage{fontspec} 
\usepackage[scale=0.7]{geometry} 
\usepackage[french]{babel}% pour un document en français.
\usepackage{verbatim}
% \usepackage{minted}
\usepackage[colorlinks=true, linkcolor=blue]{hyperref}
\usepackage{amsmath}
\usepackage{lmodern}
% \usepackage{setspace}
\usepackage{graphicx}
% \usepackage{array}
% \usepackage{xfrac}
% \usepackage{xcolor}
% \usepackage{multicol}
\usepackage[T1]{fontenc}
% \usepackage{pygmentize}
\usepackage{tkz-graph}
\usepackage{pgf,tikz}
% \usepackage{mathrsfs}
% \usepackage{typewriter}
% \usepackage[document]{ragged2e}

% \usemintedstyle{emacs}
\newenvironment{Figure}
  {\par\medskip\noindent\minipage{\linewidth}}
  {\endminipage\par\medskip}

\usepackage{caption}
\author{Loris \textsc{Croce}}
\title{\textsc{Systèmes d'exploitation}\\ \emph{Notes de cours}}
\date{}
% \subtitle{Université Blaise Pascal, Licence Informatique 2\ieme{} année}

\begin{document}

\maketitle
\tableofcontents

\section[Gestion des processus. à la Linux]{Gestion des processus {\normalfont\emph{à la Linux}}}

Multi-processus, à chaque instant $t$, un seul processus sur le processeur → Le système fait l'entrelacement entre les processus, ce qui donne une illusion de parallélisme. → Gestion de priorité avec un ordonnanceur

Pour gérer ceci on utilise une table des processus (lorsque l'on fait un appel système à fork c'est l'index dans cette table qui est retourné).

Par exemple un case de cette table peut contenir 3 classes d'information :

\begin{itemize}
\item informations sur la gestion du processus : valeurs registres, compteur ordinal, pointeur sur la pile, numéro de processus parent, tableau d'interruptions, \dots
\item informations sur la mémoire : pointeur segment du code, pointeur segment données, pointeur segment pile
\item informations sur les fichiers : description de fichiers, identifiant groupe utilisateur, \dots
\end{itemize}

Pour ces informations une partie doit se trouver en mémoire (autant que possible)
(autant que possible) ces informations sont regroupées en 2 catégories : 

\begin{itemize}
\item Celle pour le système (à ne pas déplacer en disque).
\item Celle utilisateur que l'on n'a pas besoin de garder en mémoire.
\end{itemize}

Lorsque le système décide changer de processus, il fait ce que l'on appelle un changement de contexte. Cela consiste à stocker les informations du processus courant et à charger les informations du processus suivant (choix de ce dernier délégué à l'ordonnanceur) et à demander au processus de commencer l'exécution du processus choisi.

\paragraph{Exemple d'opérations}

\begin{itemize}
\item Au niveau matériel on stocke le compteur ordinal; ...
\item Au niveau matériel on charge le nouveau compteur ordinal (pour exécuter du code du Système d'exploitation)
\item Par exemple à ce stade on peut continuer le stockage des informations du processus courant.
\end{itemize}

On peut commencer l’exécution  du code du système d'exploitation.

\begin{itemize}
    \item chargement pile (au niveau assembleur par exemple)
    \item typiquement l’ordonnanceur qui choisit le prochain processus)
\end{itemize}

On retourne au niveau assembleur pour charger les informations du processus courant et commencer son exécution.

\subsection{Politique d'ordonnancement}

L'ordonnanceur choisit le processus à exécuter en maintenant souvent les structures de données suivantes :

\begin{itemize}
\item le processus courant 
\item la liste des processus prêts à s'exécuter, en attente, zombies, \dots (ceci peut-être codé avec un drapeau)
\item la liste des interruptions. Pour chacune les processus en attente (et peut-être traitement à faire !)
\end{itemize}

\subsection{Automate des états du processus}

L'ordonnanceur choisit à chaque changement de contexte un paramètres les prêt à s'exécuter, il peut choisir 1 politique de :

\begin{itemize}
\item FIFO le processus prêts à s'exécuter sont dans une file. Inconvénient le processus avec beaucoup d'appels bloquants sont désavantagés
\item On peut améliorer le FIFO en gérant des priorités. L est une file de priorités
\item Anneaux : chacun a un temps qui lui est imparti et ce temps doit être utilisé avant 1 changement de contexte. On désavantage les autres qui ne sont pas en attente (ceux en attente occupant le processus sans rien faire)
\end{itemize}

Solution pour ne pas désavantager ceux qui ne son pas en attente :
 
\begin{itemize}
\item si 1 processus en attente et son temps pas terminé, donné la main à 1 autre.
\item lorsque le processus en attente est réveillé : 
    \begin{itemize}
    \item soit lui donner la main automatiquement (avec le temps qui lui restait)
    \item soit la prochaine fois lui ajouter ce temps à son temps imparti
    \end{itemize}
\end{itemize}

Les priorités dépendant du nombre d'exécutions à exécuter (par exemple on choisit toujours le plus court on le 2 plus courts, \dots)

Comment décider du nombre d'instructions à exécuter ? On fait des stats basées sur le passé.

L'ordonnanceur peut choisir 1 politique de la liste des pcs à s’exécuter = L.)

\begin{itemize}
\item Susteme interactif : on prend en compte les types d'instructions et on met à jour les priorités
    \begin{itemize}
        \item On fait des statistiques basées sur le passé (et ou futur danger peut être instructions non autorisées)
    \end{itemize}
\item Mix : priorité + système interactif
\end{itemize}

\section{Le dîner des philosophes}

5 philosophes assis autour d'une table et on commandé un plat (supposé infini) de spaghettis. Cinq fourchettes sont disposées autour de la table, une entre chaque assiette. Chaque philosophe passe alternativement dans 3 états : \emph{en train de penser, affamé, en train de manger}. Tout d'abord, il pense pendant un temps aléatoire. Puis, il est affamé et attend que la fourchette à sa gauche et que la fourchette ) sa droite se libèrent. Ensuite, il prend les deux fourchettes et commence à manger pendant un temps aléatoire. Quand il a fini de manger, le philosophe pense (jusqu'à ce qu'il soit à nouveau affamé).

\paragraph{Question 1} \emph{Pourquoi chaque philosophe est-il modélisé par un processus ? Est-ce qu'autre chose est modélisé par un processus ?}

Un philosophe est un processus car il effectue des calculs. Non les autres éléments sont des ressources.

\paragraph{Question 2} \emph{Quelles sont les ressources critiques ?}

La fourchette.

\paragraph{Question 3} \emph{Quand un philosophe doit-il demander la ressource ?}

Quand il est affamé.

\paragraph{Question 4} \emph{Quand un philosophe doit-il libérer la ressource ?}

Quand il a fini de manger.

\paragraph{Question 5} \emph{Quelle est la section critique ?}

C'est ``Manger", c'est la seule fonction qui utilise des ressources critiques.

\paragraph{Question 6} \emph{Pour protéger l'utilisation des fourchettes dans la section critique, nous allons implémenter une sémaphore par fourchette? Décrivez le pseudo-code d'un programme qui implémente le dîner des philosophes de la manière suivante :}

    \begin{itemize}
    \item \emph{Chaque philosophe pense pendant un temps aléatoire,}
    \item \emph{Chaque philosophe mange pendant un temps aléatoire,}
    \item \emph{L'accès aux ressources critiques est protégé.}
    \end{itemize}

Exclusion mutuelle sur chaque fourchette variable de verrouillage

    \begin{verbatim}
    while(true) {
        penser();
        prendre_semaphore_gauche();
        prendre_fourchette_gauche();
        prendre_semaphore_droite();
        prendre_fourchette_droite();
        manger();
        liberer_fourchette_gauche();
        liberer_semaphore_droite();
        librerer_fourchette_gauche();
        liberer_semaphore_gauche();
    }
    \end{verbatim}

\paragraph{Question 7} \emph{Qu'est-ce qu'un interblocage ?}

Quand aucun processus ne peut entrer en section critique (ici manger). Il se produit lorque tout les philosophes ont faim et prennent tous la fourchette

\paragraph{Question 8} \emph{Est-ce que votre solution est susceptible de faire apparaitre un interblocage ?}

Oui (exemple du carrefour priorité à droite).

\paragraph{Exercice 2} \emph{Est-ce que l'interblocage est susceptible d'arriver en pratique ?}

Oui même si la probabilité est très faible.

\paragraph{Question 9}

Oui

\paragraph{Question 10} \emph{Comment faire en sorte que le problème soit résolu sans interblocage ?}

\begin{enumerate}
\item Un sémaphore pour les deux fourchettes
\item Un processus serveur que saura qui a la fourchette
\item Philosophe indice pair prenne la fourchette droite en premier, et indice impaire gauche
\end{enumerate}

Ou

\begin{enumerate}
\item Ne donner que deux fourchettes à la fois, pas une.
\item Un processus ``serveur" est chargé de distribuer les ressources.
    Accepter 2 au plus qui mangent
\end{enumerate}

\paragraph{Question 11} \emph{Chaque philosophe ne peut prendre que la fourchette à sa gauche et à sa droite. Combien de philosophes sont autorisés à manger simultanément . Écrivez le pseudo code correspondant.}

$\frac{n}{2}$

\medskip

\section{Communication entre processus}

\paragraph{Question 13} \emph{Il existe plusieurs mécanismes de communications entre processus : les fichiers, les signaux, les sockets, les tubes nommés, les tubes anonymes; ou encore les segments de mémoire partagée. Pour chacun de ces mécanismes, indiquez : 
	\begin{itemize}
		\item Si les processus communicants peuvent être sur des machines différentes
		\item Si les processus communicants doivent avoir une relation de parenté
		\item Si les opérations de lecture et d'écriture doivent être réalisées en exclusion mutuelle
	\end{itemize}}

\begin{table}[!h]
\centering
\caption{My caption}
\label{my-label}
\begin{tabular}{|c|c|c|c|}
\hline
 & \textbf{\begin{tabular}[c]{@{}c@{}}Processus\\  peuvent être \\ dans des machines \\ différentes\end{tabular}} & \textbf{\begin{tabular}[c]{@{}c@{}}Si processus \\ communiquent\\ doivent avoir une\\  relation parenté\end{tabular}} & \textbf{\begin{tabular}[c]{@{}c@{}}Operation de\\  lecture/écriture\\ en exclusion \\ mutuelle\end{tabular}} \\ \hline
\textbf{fichiers} & oui / non & non & oui \\ \hline
\textbf{signaux} & non & non & non \\ \hline
\textbf{sockets} & oui & non & non \\ \hline
\textbf{tubes donnés} & oui / non & non & oui \\ \hline
\textbf{tubes anonymes} & non & oui & oui \\ \hline
\textbf{\begin{tabular}[c]{@{}c@{}}segments de \\ mémoire partagée\end{tabular}} & non & non & \begin{tabular}[c]{@{}c@{}}oui \\ (au moins pour l'écriture)\end{tabular} \\ \hline
\end{tabular}
\end{table}

\section{Sémaphores}

\paragraph{Question 14} \emph{exclusion mutuelle avec sémaphores} 


\begin{verbatim}
Exclusion mutuelle
  mutex = 1
  p(mutex)
  // section critique
  v(mutex)
\end{verbatim}

(\dots)

\paragraph{Question 16} \emph{On considère une barrière de synchronisation particulière : les processus A et B s'exécutent indépendamment, mais une certaine partie du code de B doit obligatoirement s'exécuter après une certaine partie du code de A. Implémentez cette barrière particulière.}

\begin{verbatim}
mutex = 0;
Processus A;
// tache non importante pour B
// tache importante pour B (section critique)
v(mutex);
// continuer traitements

Processus B;
// taches non critiques
P(mutex);
// taches critiques
\end{verbatim}

(\dots)


\section{Sections critiques (Communication)}

On dispose d'1 zone et on ne veut pas que 2 ou plus processus ``l'utilisent" en même temps.

\paragraph{Section critique :} partie du code exécuté exclusivement par les processus désignés à partager la ressource. Il y a une \textbf{``exclusion mutuelle"} lorsqu'un seul processus est habilité à accéder à la ressource.

\subsection{Quelques exemples}

\begin{enumerate}
    \item pas 2 en même temps (en cas d'exclusion mutuelle) ou i (si i est la borne)
    \item indépendant des vitesses des processus et du nombre de processus 
    \item seul 1 processus en section critique bloque les autres
    \item On ne doit pas attendre indéfiniment l'accès à la section critique
\end{enumerate}

\subsection{Mécanismes}

Masquage des interruptions, variables de verrouillage, sémaphores.

\subsection{Rappel gestion des interruptions}

\begin{enumerate}
\item Il existe plusieurs types d'interruption : 0 → horloge, 1 → disque, 4 → tmp (appels systèmes), ...
\item Une table d'interruptions qui appelle la routine associée à chaque interruption
\end{enumerate}

\subsection{Quelques conditions}

Ces différentes étapes de la gestion des interruptions :

\begin{enumerate}
\item sauvegarde le compteur ordinal, détermine le type d'interruptions et on passe en mode noyau pour permettre l'exécution de la routine associée.
    \begin{enumerate}
    \item Dans cette routine on peut stocker le contexte du processus, (en ASM)
    \item On appelle le vrai code la routine (en général mix C, assembleur)
    \item Au retour de la procédure on retourne le contexte du processus appelant si peut continuer, sinon on passe la main à l'ordonnanceur.
    \end{enumerate}
\end{enumerate}

Masquage des interruptions (bloque les interruptions) et permet l'exécution d'un code en mode atomique.

\begin{enumerate}
\item une instruction spéciale pour bloquer les interruptions
\item on l'invoque avant d'entrer en section critique
\item réactive les interruptions en fin de de section critique
\end{enumerate}

Pas acceptable comme solution puisque qu'un processus peut s'accaparer toutes les ressources. Mais, reste une solution acceptable pour l'OS (de temps en temps) dans \textbf{un système mono-processeur}.

\subsection{Variables de verrouillage}

On définit une variable par \textbf{section critique} : c'est la variable qui conditionne à la section critique.

    \begin{verbatim}
    verrou = 1;
    while (verrou == 1);
    verrou = 1;
    section_critique();
    verrou = 0;
    \end{verbatim}

Cette solution n'est pas correcte car on n'a aucune garantie que la modification de verrou est atomique → il faut trouver un moyen de contourner la non-atomicité.

\subsubsection{Solution 1 Masquage des interruptions}

Par exemple le langage dispose d'une instruction qui permet de faire des affectations atomiques

\paragraph{Solution :} Protéger nous-mêmes l'accès à la variable avec une seconde variable 

\paragraph{1ère possibilité :} une variable tour

    \begin{verbatim}
    while (tour != p)
        section_critique();
        tour = 1-p;
    \end{verbatim}

le processus le plus lent est attendu par les autres.

Vous comprendrez que cette solution ne marche que pour 2 processus.

\subsubsection[Solution 2. variable de Petersen]{Solution 2 {\normalfont\emph{variable de Petersen}}}

    \begin{verbatim}
    int drapeau = {F, F};
    int tour = 0;
    enter_sec(int i) {
    drapeau[i] = T;
    tour = i;
    while (drapeau[i+1]%2 == F || tour = (i+1) % 2)
        esc();
        sortie_esc(int i);
        drapeau[i] = F;
    }
    \end{verbatim}

\paragraph{L'étendre à $n$ processus ?} Pour une extension à $n$ processus, $m$ processeurs (avec un mécanisme de variable d'alternance).

On dispose d'une instruction matérielle \verb|test, set , lock| → changer le contenu d'une mémoire. On met une valeur non nulle à cette zone mémoire, l'atomicité garantit par un verrouillage du bus de données.

    \begin{verbatim}
    TSL(4 verrou) {old = verrou; verrou = 1; return old;}
    enter_sl() {
        while (TSL(4 verrou))
            sortie_sc() {
                verrou = 0;
            }
    }
    \end{verbatim}


\section{Autre}

\paragraph{Processus} Programme qui tourne en machine

	\begin{itemize}
	\item ensemble d'instruction et de données
	\item structure alloué par le système pour le contrôleur
	\end{itemize}

\paragraph{Un sémaphore} est une \textbf{variable} partagée par différents \textbf{acteurs}, qui garantit que ceux-ci ne peuvent y accéder que de façon séquentielle à travers des opération atomique, et constitue la méthode utilisé couramment pour restreindre l'accès à des ressources partagées.

Un processus s'apparente à un programme, un processeur effectue des calculs. Les processus donnent des instructions au processeur.

\begin{figure}[h]
\centering
\begin{tikzpicture}[scale=1.75]
\GraphInit[vstyle=Normal]
\Vertex[x=0,y=0]{Pret}
\Vertex[x=2,y=0]{Actif}
\Vertex[x=0,y=2]{Attente}
\Vertex[x=2,y=2]{Zombie}
\tikzset{EdgeStyle/.style={->}}
\Edge[style={bend right}](Pret)(Actif)
\Edge[style={bend right}](Actif)(Pret)
\Edge[style={bend right}](Actif)(Attente)
\Edge[style={bend right}](Attente)(Pret)
\Edge[style={bend left}](Attente)(Zombie)
\Edge[style={bend right}](Actif)(Zombie)
\end{tikzpicture}
\caption{États d'un processus}
\end{figure}

\subsection{Mémoire}

Algorithme de gestion de mémoire par liste chaînée : blocs de taille $t$, numérotés de $1$ à $b$. $\mbox{Liste chaînée d’éléments :} \begin{cases} \mbox{bloc de début}\\ \mbox{nombre de blocs} \\ \mbox{drapeau libre} \end{cases}$

% \begin{verbatim}
% element allocation(int n) {
%   for (int i = 0; i < listeChaine.taille; i++) {
%     if (listeChaine[i].drapeau == ``libre'') {
%       if (listeChaine[i].nbBlocs × t >= n) {
%         return listeChaine[i];
%       }
%       else {
%         while (listeChaine.suivant.drapeau == ``libre'') {
%           fusionner(listecChaine.actuel = listeChaine.suivant);
%           tester(nombreBlocs × t >= n);
%         }
%       }
%     }
%   }
% }
% \end{verbatim}

 \begin{verbatim}
 nbr_nece = entier_sup(n/t)
 pour chaque element e de liste
  si e est libre :
     si e.nb_blocs >= nb_nece
       marquer occupé
     sinon
       divisiée e en blocs :
         - marquer le 1er occupé de taille nb_nece
         - le 2eme reste libre libre nouv;
         insererElement(liste, nouv)
     return e;
  return null;
 \end{verbatim}

\end{document}