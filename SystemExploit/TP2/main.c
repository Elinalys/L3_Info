#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/wait.h> 

int compterMots(const char *chaine) {
  char tampon[64];
  int compteur = 0, taille = 0;

  if (chaine) {
    while (sscanf(chaine += taille, "%63s%n", tampon, &taille) == 1) compteur++;
  }

  return compteur;
}

int main(int argc, char const *argv[]) {
	char **arguments;
	char *tok;
	char buffer[50];
	int i;
	int nbMots = 0;
	pid_t pid;
	int presenceEt = 0;
	extern char **environ;


	while (strcmp(buffer,"quit") != 0 && strcmp(buffer,"exit") != 0)	{
		printf("$ ");
   	//on lit maximum 49 caracteres sur stdin (entr√©e standard)
   	fgets(buffer, 49, stdin); 
		buffer[strlen(buffer)-1] = '\0';
		nbMots = compterMots(buffer);
		tok = strtok(buffer, " ");
		i = 0;
		arguments = malloc(sizeof(char *) *nbMots);
		while (tok != NULL)	{
			if(strcmp(tok,"&") != 0) {	
				arguments[i] = tok;
				i++;
			}
			else {
				// printf("presenceEt a 1\n");
				presenceEt = 1;
			}
			tok = strtok(NULL, " ");
		}
		if (strcmp(buffer, "cd") == 0) {
			// printf("oui\n");
			chdir(arguments[1]);
		}
		arguments[i] = NULL;

		pid = fork();

		switch (pid) {
			case -1:
				perror("fork");
				return EXIT_FAILURE;
				break;

			case 0:
				execvp(arguments[0], arguments);
				// printf("Fin fils\n");
				break;

			default:
				if (!presenceEt) {
				// printf("Entree wait\n");
				waitpid(pid, NULL, 0);
				}
				// printf("Pere continue\n");
				break;
		}
		presenceEt = 0;
	}

	return 0;
}



